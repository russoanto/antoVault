
// XENO: This struct is not officially documented
// XENO: But this is what people have reverse engineered
struct _MDL {
  struct _MDL      *Next;
  CSHORT           Size;
  CSHORT           MdlFlags;
  struct _EPROCESS *Process;
  PVOID            MappedSystemVa;
  PVOID            StartVa;
  ULONG            ByteCount;
  ULONG            ByteOffset; 
} MDL, *PMDL;
// XENO: Struct is followed by a variable-length array
// XENO: Of physical-address (frame) pointers

#define MmInitializeMdl	(_MemoryDescriptorList,
                         _BaseVa,
                         _Length 
)
{ \
  (_MemoryDescriptorList)->Next = (PMDL) NULL; \
  (_MemoryDescriptorList)->Size = (CSHORT) (sizeof(MDL) + \
    (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(_BaseVa, _Length))); \
  (_MemoryDescriptorList)->MdlFlags = 0; \
  (_MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN(_BaseVa); \
  (_MemoryDescriptorList)->ByteOffset = BYTE_OFFSET(_BaseVa); \
  (_MemoryDescriptorList)->ByteCount = (ULONG) _Length; \
}

PMDL TransferMdl;
NTSTATUS Status;
PMDL UndoMdl;

// Obtain a mapping to the undo MDL.

Status = SkmmMapDataTransfer(DataMdl, //XENO: DataMdl ACID in
                              TransferPfn,
                              SkmmMapRead,
                              &TransferMdl, //XENO: TransferMdl ACID out
                              NULL);

if(!NT_SUCCESS(Status)) {
	return Status;
}

UndoMdl = SkAllocatePool(NonPagedPoolNx, TransferMdl->ByteCount, 'ldmM');

if(UndoMdl == NULL){
	goto CleanupAndExit;
}

OriginalUndoMdl = TransferMdl->MappedSystemVa; //XENO: Attacker controls data at address, not address itself
MmInitializeMdl(UndoMdl, (PVOID)OriginalUndoMdl->ByteOffset, OriginalUndoMdl->ByteCount);

