# TODO List
- [ ] Valutare la bontà delle differenti soluzioni di #detection
	- [ ] L'unica soluzione valida è tramite un dataset **NON SINTETICO**
		- [ ] Ho bisogno di un metodo per sincronizzare il tempo tra due bag, i timestamp non sono sincronizzati ovviamente
			- idea 1: faccio un nodo che mi stampa su entrambe le macchinine il tempo UTC e dopo manualmente sincronizzo le bag

### Steps to Synchronize Timestamps with a Common UTC Reference

1. **Subscribe to the Common UTC Time Reference**:
    
    - Ensure both nodes subscribe to a common UTC time source, like the `/utc_time` topic from the `utc_time_publisher`.
    - Each node can then retrieve the latest UTC time along with its local timestamp when the message is received.
2. **Calculate the Offset Between Local Time and UTC Time**:
    
    - When each node receives the UTC time message, it can compare the received UTC time with its local time (using the system clock or ROS time).
    - The difference between the UTC time (as received from the `/utc_time` message) and the local time gives the **time offset** for that node.
#### Sync
- When you have a common UTC time reference, you can synchronize two different timestamps by calculating the offset between the two clocks and adjusting the timestamps accordingly.
```cpp
			    double local_time = get_current_time();  // Local system time in seconds
				double utc_time = received_utc_time;     // UTC time from /utc_time topic
				double offset = local_time - utc_time;
```
- **Adjust Timestamps Using the Calculated Offset**:
	- For each timestamp generated by a node, adjust it by subtracting the calculated offset. This adjusted timestamp is now aligned with the UTC reference, allowing both nodes to have synchronized timestamps.
- **Publish or Use Synchronized Timestamps**:
	- If needed, publish the adjusted timestamps for use by other nodes, or use them internally for coordinated processing across nodes.
```cpp
#include <rclcpp/rclcpp.hpp>
#include <builtin_interfaces/msg/time.hpp>

class NodeA : public rclcpp::Node
{
public:
    NodeA() : Node("node_a")
    {
        subscription_ = this->create_subscription<builtin_interfaces::msg::Time>(
            "utc_time", 10, std::bind(&NodeA::handle_utc_time, this, std::placeholders::_1));
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(100), std::bind(&NodeA::generate_synchronized_timestamp, this));
    }

private:
    void handle_utc_time(const builtin_interfaces::msg::Time::SharedPtr utc_msg)
    {
        // Convert UTC time from message to seconds
        double utc_time = utc_msg->sec + utc_msg->nanosec * 1e-9;
        
        // Get local time in seconds
        auto now = this->now();
        double local_time = now.seconds();

        // Calculate offset between local time and UTC time
        offset_ = local_time - utc_time;
        RCLCPP_INFO(this->get_logger(), "Calculated offset: %.9f", offset_);
    }

    void generate_synchronized_timestamp()
    {
        // Get the current local time
        auto now = this->now();
        double local_time = now.seconds();

        // Adjust local time by the offset to align with UTC
        double synchronized_timestamp = local_time - offset_;
        
        RCLCPP_INFO(this->get_logger(), "Synchronized timestamp: %.9f", synchronized_timestamp);
    }

    rclcpp::Subscription<builtin_interfaces::msg::Time>::SharedPtr subscription_;
    rclcpp::TimerBase::SharedPtr timer_;
    double offset_{0.0};  // Offset between local time and UTC time
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<NodeA>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}

```

# Detection

## Datmo
- clustering
	- euclideo
	- ![[bare_conf.pdf]]
- icp method
	- pcl variant
	- **fast_gicp**: per adesso è perfetto
	- ...

# Traking
![[2015IJRR_wang.pdf]]

![[Tracker ETH]]

- Se il tutto mi è chiaro con il traking dopo ho accesso anche alla associazione dei track, ogni aggiornamento dello stato ho una predizione degli stati che posso confronotare con le misurazioni attuali faccio un confronto di similarità per la persistenza dei cluster
- 